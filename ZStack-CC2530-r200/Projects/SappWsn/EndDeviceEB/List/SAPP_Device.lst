###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               21/Aug/2019  18:59:14
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\Source\SAPP_Device.c
#    Command line       =  
#        -f C:\Users\LENOVO\AppData\Local\Temp\EW85.tmp
#        (D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\Source\SAPP_Device.c
#        -D NWK_AUTO_POLL -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D
#        MT_ZDO_FUNC -D SAPP_ZSTACK -lC
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\EndDeviceEB\List
#        -lA
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\EndDeviceEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0092
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\ -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\Source\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\EndDeviceEB\List\SAPP_Device.lst
#    Object file        =  
#        D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\EndDeviceEB\Obj\SAPP_Device.r51
#
###############################################################################

D:\IoT_hardware\实验指导书\ZStack-CC2530-r200\Projects\SappWsn\Source\SAPP_Device.c
      1          #if defined(SAPP_ZSTACK)
      2          #include "SAPP_Device.h"

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1
      3          #include "hal_io.h"
      4          #include <string.h>
      5          
      6          
      7          /********************************/
      8          /* 协调器代码                   */
      9          /********************************/
     10          #if defined(ZDO_COORDINATOR)
     11          uint8 descPkg[] = {
     12              0x03, DevIRPers, 0
     13          };
     14          
     15          static uint16 nodeNwkAddr[Devmax];
     16          static uint8 nodeEndPoint[Devmax];
     17          
     18          static uint8 irPersStatus = 0;
     19          static uint8 illumStatus = 0;
     20          static uint8 controlStatus = 0;
     21          void roomPwrManSys_StaChgRt(struct ep_info_t *ep);
     22          void roomPwrManSys_StaChgRt(struct ep_info_t *ep){}
     23          
     24          void roomPwrManSys_IncmRt(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
     25          void roomPwrManSys_IncmRt(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
     26          {
     27              //msg->Data[], msg->DataLength, msg->TransSeqNumber
     28              if((endPoint == CONTROL_ENDPOINT) && (msg->Data[0] == 0x03))
     29              {
     30                  // endPoint: msg->Data[1], rCycle: msg->Data[2]
     31                  // 将上一次寻找的节点地址和端点号保存起来
     32                  nodeNwkAddr[descPkg[1]] = addr;
     33                  nodeEndPoint[descPkg[1]] = msg->Data[1];
     34                  // 准备寻找下一个节点
     35                  descPkg[1] = descPkg[1] + 1;
     36                  // 所有节点是否都已经寻找完毕?
     37                  if(descPkg[1] < Devmax)
     38                      SendData(ep->ep, descPkg, 0xFFFF, CONTROL_ENDPOINT, sizeof(descPkg));
     39              }
     40              else
     41              {
     42                  if(addr == nodeNwkAddr[DevIllum])
     43                  {
     44                      // 接收到光照度传感器数据
     45                      uint16 i = 0;
     46                      memcpy(&i, msg->Data, 2);
     47                      illumStatus = i < 45000;
     48                      HalUARTWrite(HAL_UART_PORT_0, msg->Data, 2);
     49                  }
     50                  if(nodeNwkAddr[DevExecuter] != 0xFFFF)
     51                  {
     52                      // 如果执行节点存在
     53                      uint8 ctrl = 0;
     54                      if(irPersStatus && illumStatus)
     55                          ctrl = 0x0f;
     56                      // 如果灯光的当前状态与需要设置的状态不一样则发送数据
     57                      if(controlStatus != ctrl)
     58                          SendData(ep->ep, &ctrl, nodeNwkAddr[DevExecuter], nodeEndPoint[DevExecuter], 1);
     59                      controlStatus = ctrl;
     60                  }
     61              }
     62          }
     63          void roomPwrManSys_ToRt(struct ep_info_t *ep);
     64          void roomPwrManSys_ToRt(struct ep_info_t *ep)
     65          {
     66              // 超时函数,用于检查节点搜索是否完成
     67              // 如果没有完成,则继续搜索
     68              if(descPkg[1] < Devmax)
     69              {
     70                  SendData(ep->ep, descPkg, 0xFFFF, CONTROL_ENDPOINT, sizeof(descPkg));
     71              }
     72          }
     73          void roomPwrManSys_ResAvbRt(struct ep_info_t *ep, RES_TYPE type, void *res);
     74          void roomPwrManSys_ResAvbRt(struct ep_info_t *ep, RES_TYPE type, void *res)
     75          {
     76              switch(type)
     77              {
     78              case ResInit:
     79                  memset(nodeNwkAddr, 0xFF, sizeof(nodeNwkAddr));
     80                  memset(nodeEndPoint, 0xFF, sizeof(nodeEndPoint));
     81                  break;
     82              case ResUserTimer:
     83                  break;
     84              case ResControlPkg:
     85                  break;
     86              }
     87          }
     88          #endif
     89          
     90          
     91          
     92          
     93          
     94          
     95          /**************************************************************/
     96          /* 传感器列表                                                 */
     97          /**************************************************************/
     98          /********************************/
     99          /* 燃气传感器                   */
    100          /********************************/
    101          #if defined(HAS_GAS)
    102          #define GAS_IO_GROUP        0
    103          #define GAS_IO_BIT          0
    104          void sensorGasResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    105          void sensorGasResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    106          {
    107              if(type == ResInit)
    108              {
    109                  HalIOSetInput(GAS_IO_GROUP, GAS_IO_BIT, Pull_Down);
    110                  HalIOIntSet(ep->ep, GAS_IO_GROUP, GAS_IO_BIT, IOInt_Rising, 0);
    111              }
    112              //IO端口中断触发，中断源检测
    113              if(type == ResIOInt)
    114              {
    115                  uint8 GasValue = 1;
    116                  SendData(ep->ep, &GasValue, 0x0000, TRANSFER_ENDPOINT, sizeof(GasValue));
    117              }
    118          }
    119          void sensorGasTimeout(struct ep_info_t *ep);
    120          void sensorGasTimeout(struct ep_info_t *ep)
    121          {
    122              uint8 value = HalIOGetLevel(GAS_IO_GROUP, GAS_IO_BIT);
    123              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    124          }
    125          #endif
    126          /********************************/
    127          /* 温度传感器                   */
    128          /********************************/
    129          #if defined(HAS_TEMP) || defined(HAS_HUMM)
    130          #include "sht10.h"
    131          static uint16 TempValue = 0;
    132          #endif
    133          #if defined(HAS_TEMP)
    134          void sensorTempResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    135          void sensorTempResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    136          {
    137              if(type == ResInit)
    138              {
    139                  SHT10_init(0x01);
    140              }
    141          }
    142          void sensorTempTimeout(struct ep_info_t *ep);
    143          void sensorTempTimeout(struct ep_info_t *ep)
    144          {
    145              unsigned int value = 0;
    146              unsigned char checksum = 0;
    147              SHT10_Measure(&value,&checksum, TEMPERATURE);
    148              TempValue = (value << 2) - 3960;
    149              SendData(ep->ep, &TempValue, 0x0000, TRANSFER_ENDPOINT, sizeof(TempValue));
    150          }
    151          #endif
    152          /********************************/
    153          /* 湿度传感器                   */
    154          /********************************/
    155          #if defined(HAS_HUMM)
    156          void sensorHummResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    157          void sensorHummResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    158          {
    159              if(type == ResInit)
    160              {
    161                  SHT10_init(0x01);
    162              }
    163          }
    164          void sensorHummTimeout(struct ep_info_t *ep);
    165          void sensorHummTimeout(struct ep_info_t *ep)
    166          {
    167              const float C1 = -4.0f;              // for 8 Bit
    168              const float C2 = +0.648f;            // for 8 Bit
    169              const float C3 = -0.0000072f;        // for 8 Bit
    170              const float T1 = 0.01f;              // for 8 bit
    171              const float T2 = 0.00128f;           // for 8 bit
    172              float rh_lin    =   0.0f;                     // rh_lin: Humidity linear
    173              float rh_true   =   0.0f;                    // rh_true: Temperature compensated humidity
    174              float t_C   = 0.0f;                        // t_C   : Temperature []
    175          
    176              unsigned int HumiValue = 0;
    177              unsigned char checksum = 0;
    178              SHT10_Measure(&HumiValue,&checksum, HUMIDITY);
    179              rh_lin=C3*HumiValue*HumiValue + C2*HumiValue + C1;     //calc. humidity from ticks to [%RH]
    180              rh_true=(t_C-25)*(T1+T2*HumiValue)+rh_lin;   //calc. temperature compensated humidity [%RH]
    181              if(rh_true>100)
    182                  rh_true=100;       //cut if the value is outside of
    183              if(rh_true<0.1)
    184                  rh_true=0.1f;       //the physical possible range
    185              HumiValue = (unsigned int)(rh_true * 100);
    186              SendData(ep->ep, &HumiValue, 0x0000, TRANSFER_ENDPOINT, sizeof(HumiValue));
    187          }
    188          #endif
    189          /********************************/
    190          /* 雨滴传感器                   */
    191          /********************************/
    192          #if defined(HAS_RAIN)
    193          #define RAIN_IO_GROUP       0
    194          #define RAIN_IO_BIT         0
    195          void sensorRainResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    196          void sensorRainResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    197          {
    198              if(type == ResInit)
    199              {
    200                  HalIOSetInput(RAIN_IO_GROUP, RAIN_IO_BIT, Pull_None);
    201                  HalIOIntSet(ep->ep, RAIN_IO_GROUP, RAIN_IO_BIT, IOInt_Rising, 0);
    202              }
    203              //IO端口中断触发，中断源检测
    204              if(type == ResIOInt)
    205              {
    206                  uint8 RainValue = 1;
    207                  SendData(ep->ep, &RainValue, 0x0000, TRANSFER_ENDPOINT, sizeof(RainValue));
    208              }
    209          }
    210          void sensorRainTimeout(struct ep_info_t *ep);
    211          void sensorRainTimeout(struct ep_info_t *ep)
    212          {
    213              uint8 value = HalIOGetLevel(RAIN_IO_GROUP, RAIN_IO_BIT);
    214              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    215          }
    216          #endif
    217          /********************************/
    218          /* 火焰传感器                   */
    219          /********************************/
    220          #if defined(HAS_FIRE)
    221          #define FIRE_IO_GROUP       0
    222          #define FIRE_IO_BIT         0
    223          void sensorFireResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    224          void sensorFireResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    225          {
    226              if(type == ResInit)
    227              {
    228                  HalIOSetInput(FIRE_IO_GROUP, FIRE_IO_BIT, Pull_Down);
    229                  HalIOIntSet(ep->ep, FIRE_IO_GROUP, FIRE_IO_BIT, IOInt_Rising, 0);
    230              }
    231              //IO端口中断触发，中断源检测
    232              if(type == ResIOInt)
    233              {
    234                  uint8 FireValue = 1;
    235                  SendData(ep->ep, &FireValue, 0x0000, TRANSFER_ENDPOINT, sizeof(FireValue));
    236              }
    237          }
    238          void sensorFireTimeout(struct ep_info_t *ep);
    239          void sensorFireTimeout(struct ep_info_t *ep)
    240          {
    241              uint8 value = HalIOGetLevel(FIRE_IO_GROUP, FIRE_IO_BIT);
    242              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    243          }
    244          #endif
    245          /********************************/
    246          /* 烟雾传感器                   */
    247          /********************************/
    248          #if defined(HAS_SMOKE)
    249          #define SMOKE_IO_GROUP      0
    250          #define SMOKE_IO_BIT        0
    251          void sensorSmokeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    252          void sensorSmokeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    253          {
    254              if(type == ResInit)
    255              {
    256                  HalIOSetInput(SMOKE_IO_GROUP, SMOKE_IO_BIT, Pull_Down);
    257                  HalIOIntSet(ep->ep, SMOKE_IO_GROUP, SMOKE_IO_BIT, IOInt_Rising, 0);
    258              }
    259              //IO端口中断触发，中断源检测
    260              if(type == ResIOInt)
    261              {
    262                  uint8 SmokeValue = 1;
    263                  SendData(ep->ep, &SmokeValue, 0x0000, TRANSFER_ENDPOINT, sizeof(SmokeValue));
    264              }
    265          }
    266          void sensorSmokeTimeout(struct ep_info_t *ep);
    267          void sensorSmokeTimeout(struct ep_info_t *ep)
    268          {
    269              uint8 value = HalIOGetLevel(SMOKE_IO_GROUP, SMOKE_IO_BIT);
    270              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    271          }
    272          #endif
    273          /********************************/
    274          /* 光照度传感器                 */
    275          /********************************/
    276          #if defined(HAS_ILLUM)
    277          #include "hal_adc.h"
    278          void sensorILLumTimeout(struct ep_info_t *ep);
    279          void sensorILLumTimeout(struct ep_info_t *ep)
    280          {
    281              uint16 LightValue = 256 - (HalAdcRead(0, HAL_ADC_RESOLUTION_14) >> 3);
    282              // 将AD值变换为光照度的100倍
    283              LightValue = LightValue * 39;// * 10000 / 256;
    284              SendData(ep->ep, &LightValue, 0x0000, TRANSFER_ENDPOINT, sizeof(LightValue));
    285          }
    286          #endif
    287          /********************************/
    288          /* 安防传感器                   */
    289          /********************************/
    290          #if defined(HAS_IRPERS)
    291          #define SAFTY_IO_GROUP      1
    292          #define SAFTY_IO_BIT        0
    293          void sensorIRPersResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    294          void sensorIRPersResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    295          {
    296              if(type == ResInit)
    297              {
    298                  HalIOSetInput(SAFTY_IO_GROUP, SAFTY_IO_BIT, Pull_Down);
    299                  HalIOIntSet(ep->ep, SAFTY_IO_GROUP, SAFTY_IO_BIT, IOInt_Rising, 0);
    300              }
    301              //IO端口中断触发，中断源检测
    302              if(type == ResIOInt)
    303              {
    304                  uint8 IRPersValue = 1;
    305                  SendData(ep->ep, &IRPersValue, 0x0000, TRANSFER_ENDPOINT, sizeof(IRPersValue));
    306              }
    307          }
    308          void sensorIRPersTimeout(struct ep_info_t *ep);
    309          void sensorIRPersTimeout(struct ep_info_t *ep)
    310          {
    311              uint8 value = HalIOGetLevel(SAFTY_IO_GROUP, SAFTY_IO_BIT);
    312              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    313          }
    314          #endif
    315          /********************************/
    316          /* 红外测距传感器               */
    317          /********************************/
    318          #if defined(HAS_IRDIST)
    319          #include "hal_adc.h"
    320          extern uint16 irDistTab[256];
    321          void sensorIRDistTimeout(struct ep_info_t *ep);
    322          void sensorIRDistTimeout(struct ep_info_t *ep)
    323          {
    324              uint8 value = HalAdcRead(0, HAL_ADC_RESOLUTION_14) >> 3;
    325              // 计算距离值value的单位为mm
    326              uint16 IRDistValue = irDistTab[value];
    327              SendData(ep->ep, &IRDistValue, 0x0000, TRANSFER_ENDPOINT, sizeof(IRDistValue));
    328          }
    329          #endif
    330          /********************************/
    331          /* 语音传感器                   */
    332          /********************************/
    333          #if defined(HAS_VOICE)
    334          #include "hal_uart.h"
    335          static struct ep_info_t *voiceEndPoint = NULL;
    336          static uint8 LastVoiceData = 0;
    337          static void sensorVoiceUartProcess( uint8 port, uint8 event );
    338          static void sensorVoiceUartProcess( uint8 port, uint8 event )
    339          {
    340              (void)event;  // Intentionally unreferenced parameter
    341              while (Hal_UART_RxBufLen(port))
    342              {
    343                  HalUARTRead(port, &LastVoiceData, 1);
    344                  if(LastVoiceData == 0xAA)
    345                      LastVoiceData = 1;
    346                  else if(LastVoiceData == 0x55)
    347                      LastVoiceData = 0;
    348                  else
    349                      LastVoiceData = -1;
    350                  if(voiceEndPoint != NULL)
    351                      SendData(voiceEndPoint->ep, &LastVoiceData, 0x0000, TRANSFER_ENDPOINT, 1);
    352              }
    353          }
    354          void sensorVoiceNwkStateChange(struct ep_info_t *ep);
    355          void sensorVoiceNwkStateChange(struct ep_info_t *ep)
    356          {
    357              voiceEndPoint = ep;
    358          }
    359          void sensorVoiceResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    360          void sensorVoiceResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    361          {
    362              if(type == ResInit)
    363              {
    364                  halUARTCfg_t uartConfig;
    365          
    366                  voiceEndPoint = ep;
    367                  /* UART Configuration */
    368                  uartConfig.configured           = TRUE;
    369                  uartConfig.baudRate             = HAL_UART_BR_9600;
    370                  uartConfig.flowControl          = FALSE;
    371                  uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
    372                  uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
    373                  uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
    374                  uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
    375                  uartConfig.intEnable            = TRUE;
    376                  uartConfig.callBackFunc         = sensorVoiceUartProcess;
    377                  HalUARTOpen(HAL_UART_PORT_1, &uartConfig);
    378              }
    379          }
    380          void sensorVoiceTimeout(struct ep_info_t *ep);
    381          void sensorVoiceTimeout(struct ep_info_t *ep)
    382          {
    383              uint8 nulData = 0;
    384              SendData(ep->ep, &nulData, 0x0000, TRANSFER_ENDPOINT, 1);
    385          }
    386          #endif
    387          /********************************/
    388          /* 二进制执行器传感器           */
    389          /********************************/
    390          
    391          #if defined(HAS_EXECUTEB)
    392          #define ControlInit()   do { HalIOSetOutput(1,4);HalIOSetOutput(1,5);HalIOSetOutput(1,6);HalIOSetOutput(1,7);Control(0); } while(0)
    393          #define Control(mask)   do { HalIOSetLevel(1,4,mask&0x01);HalIOSetLevel(1,5,mask&0x02);HalIOSetLevel(1,6,mask&0x04);HalIOSetLevel(1,7,mask&0x08); } while(0)
    394          void OutputExecuteBResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    395          void OutputExecuteBResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
   \                     OutputExecuteBResAvailable:
    396          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    397              if(type == ResInit)
   \   000007   7401         MOV       A,#0x1
   \   000009   6E           XRL       A,R6
   \   00000A   7040         JNZ       ??OutputExecuteBResAvailable_0
    398                  ControlInit();
   \   00000C                ; Setup parameters for call to function HalIOSetOutput
   \   00000C   7A04         MOV       R2,#0x4
   \   00000E   7901         MOV       R1,#0x1
   \   000010   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000013                ; Setup parameters for call to function HalIOSetOutput
   \   000013   7A05         MOV       R2,#0x5
   \   000015   7901         MOV       R1,#0x1
   \   000017   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   00001A                ; Setup parameters for call to function HalIOSetOutput
   \   00001A   7A06         MOV       R2,#0x6
   \   00001C   7901         MOV       R1,#0x1
   \   00001E   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000021                ; Setup parameters for call to function HalIOSetOutput
   \   000021   7A07         MOV       R2,#0x7
   \   000023   7901         MOV       R1,#0x1
   \   000025   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000028                ; Setup parameters for call to function HalIOSetLevel
   \   000028   7B00         MOV       R3,#0x0
   \   00002A   7A04         MOV       R2,#0x4
   \   00002C   7901         MOV       R1,#0x1
   \   00002E   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000031                ; Setup parameters for call to function HalIOSetLevel
   \   000031   7B00         MOV       R3,#0x0
   \   000033   7A05         MOV       R2,#0x5
   \   000035   7901         MOV       R1,#0x1
   \   000037   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   00003A                ; Setup parameters for call to function HalIOSetLevel
   \   00003A   7B00         MOV       R3,#0x0
   \   00003C   7A06         MOV       R2,#0x6
   \   00003E   7901         MOV       R1,#0x1
   \   000040   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000043                ; Setup parameters for call to function HalIOSetLevel
   \   000043   7B00         MOV       R3,#0x0
   \   000045   7A07         MOV       R2,#0x7
   \   000047   7901         MOV       R1,#0x1
   \   000049   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
    399          }
   \                     ??OutputExecuteBResAvailable_0:
   \   00004C                REQUIRE ?Subroutine0
   \   00004C                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    400          void outputExecuteB(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    401          void outputExecuteB(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
   \                     outputExecuteB:
    402          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   740B         MOV       A,#0xb
   \   00000B   12....       LCALL     ?XSTACK_DISP0_8
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   F8           MOV       R0,A
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F9           MOV       R1,A
    403              //msg->Data[], msg->DataLength, msg->TransSeqNumber
    404              Control(msg->Data[0]);
   \   000013   E8           MOV       A,R0
   \   000014   2403         ADD       A,#0x3
   \   000016   FE           MOV       R6,A
   \   000017   E4           CLR       A
   \   000018   39           ADDC      A,R1
   \   000019   FF           MOV       R7,A
   \   00001A                ; Setup parameters for call to function HalIOSetLevel
   \   00001A   8E82         MOV       DPL,R6
   \   00001C   F583         MOV       DPH,A
   \   00001E   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000021   A2E0         MOV       C,0xE0 /* A   */.0
   \   000023   E4           CLR       A
   \   000024   33           RLC       A
   \   000025   FB           MOV       R3,A
   \   000026   7A04         MOV       R2,#0x4
   \   000028   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00002B   5402         ANL       A,#0x2
   \   00002D   FB           MOV       R3,A
   \   00002E   7A05         MOV       R2,#0x5
   \   000030   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000033   5404         ANL       A,#0x4
   \   000035   FB           MOV       R3,A
   \   000036   7A06         MOV       R2,#0x6
   \   000038   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00003B   5408         ANL       A,#0x8
   \   00003D   FB           MOV       R3,A
   \   00003E   7A07         MOV       R2,#0x7
   \   000040   7901         MOV       R1,#0x1
   \   000042   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
    405              SendData(ep->ep, &msg->Data[0], 0x0000, TRANSFER_ENDPOINT, 1);
   \   000045                ; Setup parameters for call to function SendData
   \   000045   75..01       MOV       ?V2,#0x1
   \   000048   78..         MOV       R0,#?V2
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004D   78..         MOV       R0,#?V2
   \   00004F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000052   7C00         MOV       R4,#0x0
   \   000054   7D00         MOV       R5,#0x0
   \   000056   8E82         MOV       DPL,R6
   \   000058   8F83         MOV       DPH,R7
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   FA           MOV       R2,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   FB           MOV       R3,A
   \   00005F   E5..         MOV       A,?V0
   \   000061   240B         ADD       A,#0xb
   \   000063   F582         MOV       DPL,A
   \   000065   E4           CLR       A
   \   000066   35..         ADDC      A,?V1
   \   000068   F583         MOV       DPH,A
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   F9           MOV       R1,A
   \   00006C   12....       LCALL     `??SendData::?relay`; Banked call to: SendData
   \   00006F   7402         MOV       A,#0x2
   \   000071   12....       LCALL     ?DEALLOC_XSTACK8
    406          }
   \   000074   7F03         MOV       R7,#0x3
   \   000076   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7901         MOV       R1,#0x1
   \   000002   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005   8E82         MOV       DPL,R6
   \   000007   8F83         MOV       DPH,R7
   \   000009   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   E0           MOVX      A,@DPTR
   \   000009   22           RET
    407          void outputExecuteBTimeout(struct ep_info_t *ep);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          void outputExecuteBTimeout(struct ep_info_t *ep)
   \                     outputExecuteBTimeout:
    409          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
    410              uint8 value = P1 >> 4;
   \   00000E   E590         MOV       A,0x90
   \   000010   C4           SWAP      A
   \   000011   540F         ANL       A,#0xf
   \   000013   85..82       MOV       DPL,?XSP + 0
   \   000016   85..83       MOV       DPH,?XSP + 1
   \   000019   F0           MOVX      @DPTR,A
    411              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
   \   00001A                ; Setup parameters for call to function SendData
   \   00001A   75..01       MOV       ?V0,#0x1
   \   00001D   78..         MOV       R0,#?V0
   \   00001F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000022   78..         MOV       R0,#?V0
   \   000024   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000027   7C00         MOV       R4,#0x0
   \   000029   7D00         MOV       R5,#0x0
   \   00002B   7402         MOV       A,#0x2
   \   00002D   12....       LCALL     ?XSTACK_DISP101_8
   \   000030   EE           MOV       A,R6
   \   000031   240B         ADD       A,#0xb
   \   000033   F582         MOV       DPL,A
   \   000035   E4           CLR       A
   \   000036   3F           ADDC      A,R7
   \   000037   F583         MOV       DPH,A
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   F9           MOV       R1,A
   \   00003B   12....       LCALL     `??SendData::?relay`; Banked call to: SendData
   \   00003E   7402         MOV       A,#0x2
   \   000040   12....       LCALL     ?DEALLOC_XSTACK8
    412          }
   \   000043   7401         MOV       A,#0x1
   \   000045   12....       LCALL     ?DEALLOC_XSTACK8
   \   000048   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   00004B                REQUIRE _A_P1
    413          #endif
    414          
    415          /********************************/
    416          /* 模拟执行器传感器             */
    417          /********************************/
    418          #if defined(HAS_EXECUTEA)
    419          void outputExecuteA(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    420          void outputExecuteA(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    421          {
    422          }
    423          #endif
    424          /********************************/
    425          /* 遥控器传感器                 */
    426          /********************************/
    427          #if defined(HAS_REMOTER)
    428          #include "IR.h"
    429          static uint8 lastCode[32];
    430          static uint8 lastCodeLen = 0;
    431          void IRSendResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    432          void IRSendResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    433          {
    434              if(type == ResInit)
    435                  IRSendInit();   // 需要初始化
    436          }
    437          void outputRemoter(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    438          void outputRemoter(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    439          {
    440             lastCodeLen = msg->Data[0];
    441             memcpy(lastCode, &msg->Data[1], lastCodeLen);
    442             GenIR(&msg->Data[1], IRGuideLen_9ms, (uint8)lastCodeLen);
    443             SendData(ep->ep, lastCode, 0x0000, TRANSFER_ENDPOINT, lastCodeLen>>3);
    444          }
    445          void outputRemoterTimeout(struct ep_info_t *ep);
    446          void outputRemoterTimeout(struct ep_info_t *ep)
    447          {
    448              if(lastCodeLen <= 0)
    449              {
    450                  uint8 value = 0;
    451                  SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, 1);
    452              }
    453              else
    454                  SendData(ep->ep, lastCode, 0x0000, TRANSFER_ENDPOINT, lastCodeLen>>3);
    455          }
    456          #endif
    457          /********************************/
    458          /* 虚拟功能                     */
    459          /********************************/
    460          #if defined(HAS_TESTFUNCTION)
    461          #define TEST_STRING     "Z-Stack for SAPP"
    462          static uint8 lastData[119] = TEST_STRING;
    463          static uint8 lastLen = 0;
    464          void testFunc_RecvData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    465          void testFunc_RecvData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    466          {
    467              lastLen = msg->DataLength;
    468              memcpy(&lastData[sizeof(TEST_STRING) - 1], msg->Data, lastLen);
    469              SendData(ep->ep, lastData, 0x0000, TRANSFER_ENDPOINT,
    470                               lastLen + sizeof(TEST_STRING) - 1);
    471          }
    472          void testFunc_TimeOut(struct ep_info_t *ep);
    473          void testFunc_TimeOut(struct ep_info_t *ep)
    474          {
    475              SendData(ep->ep, lastData, 0x0000, TRANSFER_ENDPOINT,
    476                               lastLen + sizeof(TEST_STRING) - 1);
    477          }
    478          #endif
    479          /********************************/
    480          /* 广播发送功能                 */
    481          /********************************/
    482          #if defined(HAS_BROADCASTSEND)
    483          #define BROADCAST_STRING     "\r\nBroadcast Message\r\n"
    484          void BroadcastSend_TimeOut(struct ep_info_t *ep);
    485          void BroadcastSend_TimeOut(struct ep_info_t *ep)
    486          {
    487              SendData(ep->ep, BROADCAST_STRING, 0XFFFF, TRANSFER_ENDPOINT,
    488                               sizeof(BROADCAST_STRING) - 1);
    489              //广播后指示灯 LED_D9 闪烁2次
    490              HalLedBlink( HAL_LED_2, 2, 50, 100 );
    491          }
    492          #endif
    493          /********************************/
    494          /* 广播接收功能                 */
    495          /********************************/
    496          #if defined(HAS_BROADCASTRECEIVE)
    497          void BroadcastReceiveData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    498          void BroadcastReceiveData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    499          {
    500              //收到广播数据后 LED_D8 连续闪烁4次!
    501              HalLedBlink( HAL_LED_1, 4, 50, 120 );
    502              HalUARTWrite(HAL_UART_PORT_0, msg->Data, msg->DataLength);
    503          }
    504          #define BROADCAST_STRING     "Broadcast Message"
    505          void BroadcastSend_TimeOut(struct ep_info_t *ep);
    506          void BroadcastSend_TimeOut(struct ep_info_t *ep)
    507          {
    508              SendData(ep->ep, BROADCAST_STRING, 0X0000, TRANSFER_ENDPOINT,
    509                               sizeof(BROADCAST_STRING) - 1);
    510          }
    511          #endif
    512          /********************************/
    513          /* IC卡读卡器                   */
    514          /********************************/
    515          #if defined(HAS_125KREADER)
    516          #include "hal_uart.h"
    517          #define CARDID_SIZE     5                   // 卡号长度
    518          static uint8 lastCardId[CARDID_SIZE];       // 用来保存接收到的卡号
    519          static uint8 cardRecvIdx;                   // 上一次接收到的长度
    520          static uint32 lastTick;                     // 上一次接收数据的系统时间
    521          static struct ep_info_t *cardEndPoint;
    522          static void sensor125kReaderUartProcess( uint8 port, uint8 event );
    523          static void sensor125kReaderUartProcess( uint8 port, uint8 event )
    524          {
    525              (void)event;  // Intentionally unreferenced parameter
    526              if((lastTick + 100) <= osal_GetSystemClock())
    527              {                                       // 如果本次接收到的时间距离上次超过了0.1秒
    528                  cardRecvIdx = 0;                    // 则清空计数器，重新接收卡号
    529              }
    530              lastTick = osal_GetSystemClock();       // 记录下当前的时间
    531              while (Hal_UART_RxBufLen(port))
    532              {
    533                  uint16 restLen = Hal_UART_RxBufLen(port);
    534                  if(restLen > (CARDID_SIZE - cardRecvIdx))
    535                      restLen = CARDID_SIZE - cardRecvIdx;
    536                  HalUARTRead(port, &lastCardId[cardRecvIdx], restLen);
    537                  cardRecvIdx += restLen;
    538                  if(cardRecvIdx >= CARDID_SIZE)      // 如果已经接收完成一个完整的卡号
    539                  {                                   // 则发送给协调器
    540                      SendData(cardEndPoint->ep, lastCardId, 0x0000, TRANSFER_ENDPOINT, CARDID_SIZE);
    541                  }
    542              }
    543          }
    544          void sensor125kReaderResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    545          void sensor125kReaderResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    546          {
    547              if(type == ResInit)
    548              {
    549                  halUARTCfg_t uartConfig;
    550          
    551                  memset(lastCardId, 0, sizeof(lastCardId));
    552                  cardRecvIdx = 0;
    553                  cardEndPoint = ep;
    554                  /* UART Configuration */
    555                  uartConfig.configured           = TRUE;
    556                  uartConfig.baudRate             = HAL_UART_BR_19200;
    557                  uartConfig.flowControl          = FALSE;
    558                  uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
    559                  uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
    560                  uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
    561                  uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
    562                  uartConfig.intEnable            = TRUE;
    563                  uartConfig.callBackFunc         = sensor125kReaderUartProcess;
    564                  HalUARTOpen(HAL_UART_PORT_0, &uartConfig);
    565              }
    566          }
    567          void sensor125kReaderTimeout(struct ep_info_t *ep);
    568          void sensor125kReaderTimeout(struct ep_info_t *ep)
    569          {
    570              uint8 nullId[CARDID_SIZE] = { 0x00 };
    571              SendData(cardEndPoint->ep, nullId, 0x0000, TRANSFER_ENDPOINT, CARDID_SIZE);
    572          }
    573          #endif
    574          /********************************/
    575          /* 语音播放节点                 */
    576          /********************************/
    577          #if defined(HAS_SPEAKER)
    578          void OutputSpeakerResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    579          void OutputSpeakerResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    580          {
    581              if(type == ResInit)
    582                  HalUART1HwInit();
    583          }
    584          void outputSpeaker(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    585          void outputSpeaker(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    586          {
    587              //msg->Data[], msg->DataLength, msg->TransSeqNumber
    588              HalUART1HwTxByte(msg->Data[0]);
    589          //    SendData(ep->ep, &msg->Data[0], 0x0000, TRANSFER_ENDPOINT, 1);
    590          }
    591          void outputSpeakerTimeout(struct ep_info_t *ep);
    592          void outputSpeakerTimeout(struct ep_info_t *ep)
    593          {
    594              uint8 value = 0;
    595              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    596          }
    597          #endif
    598          /********************************/
    599          /* 红外接收解码                 */
    600          /********************************/
    601          #if defined(HAS_IRDecode)
    602          #include <hal_irdec.h>
    603          void IRDecodeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    604          void IRDecodeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    605          {
    606              if(type == ResInit)
    607              {
    608                  IRDecodeT1Init(ep->task_id, ep->ep);
    609              }
    610              //定时器1通道0一次红外解码结束,向上传送解码结果
    611              if(type == ResTimerInt)
    612              {
    613                  OSALIRDecData_t *irData = (OSALIRDecData_t *)res;
    614                  SendData(ep->ep, irData->irCode, 0x0000, TRANSFER_ENDPOINT, irData->irLen);
    615              }
    616          }
    617          void IRDecodeTimeout(struct ep_info_t *ep);
    618          void IRDecodeTimeout(struct ep_info_t *ep)
    619          {
    620              uint8 value = 0;
    621              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    622          }
    623          #endif
    624          
    625          /***************************************************/
    626          /* 节点功能列表                                    */
    627          /***************************************************/

   \                                 In  segment XDATA_I, align 1, keep-with-next
    628          struct ep_info_t funcList[] = {
   \                     funcList:
   \   000000                DS 33
   \   000021                REQUIRE `?<Initializer for funcList>`
   \   000021                REQUIRE __INIT_XDATA_I
    629          #if defined(HAS_GAS)
    630              {
    631                  // 加入网络,收到数据,超时处理,资源变化
    632                  NULL, NULL, sensorGasTimeout, sensorGasResAvailable,
    633                  { DevGas, 0, 5 },                   // type, id, refresh cycle
    634              },
    635          #endif
    636          #if defined(HAS_TEMP)
    637              {
    638                  NULL, NULL, sensorTempTimeout, sensorTempResAvailable,
    639                  { DevTemp, 1, 5 },                 // type, id, refresh cycle
    640              },
    641          #endif
    642          #if defined(HAS_HUMM)
    643              {
    644                  NULL, NULL, sensorHummTimeout, sensorHummResAvailable,
    645                  { DevHumm, 0, 5 },                 // type, id, refresh cycle
    646              },
    647          #endif
    648          #if defined(HAS_ILLUM)
    649              {
    650                  NULL, NULL, sensorILLumTimeout, NULL,
    651                  { DevILLum, 0, 3 },                // type, id, refresh cycle
    652              },
    653          #endif
    654          #if defined(HAS_RAIN)
    655              {
    656                  NULL, NULL, sensorRainTimeout, sensorRainResAvailable,
    657                  { DevRain, 0, 5 },                 // type, id, refresh cycle
    658              },
    659          #endif
    660          #if defined(HAS_IRDIST)
    661              {
    662                  NULL, NULL, sensorIRDistTimeout, NULL,
    663                  { DevIRDist, 0, 3 },               // type, id, refresh cycle
    664              },
    665          #endif
    666          #if defined(HAS_SMOKE)
    667              {
    668                  NULL, NULL, sensorSmokeTimeout, sensorSmokeResAvailable,
    669                  { DevSmoke, 0, 5 },                 // type, id, refresh cycle
    670              },
    671          #endif
    672          #if defined(HAS_FIRE)
    673              {
    674                  NULL, NULL, sensorFireTimeout, sensorFireResAvailable,
    675                  { DevFire, 0, 3 },                  // type, id, refresh cycle
    676              },
    677          #endif
    678          #if defined(HAS_IRPERS)
    679              {
    680                  NULL, NULL, sensorIRPersTimeout, sensorIRPersResAvailable,
    681                  { DevIRPers, 0, 2 },                // type, id, refresh cycle
    682              },
    683          #endif
    684          #if defined(HAS_VOICE)
    685              {
    686                  sensorVoiceNwkStateChange, NULL, sensorVoiceTimeout, sensorVoiceResAvailable,
    687                  { DevVoice, 0, 5 },                // type, id, refresh cycle
    688              },
    689          #endif
    690          #if defined(HAS_EXECUTEB)
    691              {
    692                  NULL, outputExecuteB, outputExecuteBTimeout, OutputExecuteBResAvailable,
    693                  { DevExecuteB, 3, 10 },              // type, id, refresh cycle
    694              },
    695          #endif
    696          #if defined(HAS_EXECUTEA)
    697              {
    698                  NULL, outputExecuteA, NULL, NULL,
    699                  { DevExecuteA, 0, 3 },              // type, id, refresh cycle
    700              },
    701          #endif
    702          #if defined(HAS_REMOTER)
    703              {
    704                  NULL, outputRemoter, outputRemoterTimeout, IRSendResAvailable,
    705                  { DevRemoter, 0, 3 },              // type, id, refresh cycle
    706              },
    707          #endif
    708          #if defined(HAS_TESTFUNCTION)
    709              {
    710                  NULL,
    711                  testFunc_RecvData,
    712                  testFunc_TimeOut,
    713                  NULL,
    714                  { DevTest, 0, 3 },
    715              },
    716          #endif
    717          #if defined(HAS_BROADCASTSEND)
    718              {
    719                  NULL,
    720                  NULL,
    721                  BroadcastSend_TimeOut,
    722                  NULL,
    723                  { DevBroadcastSend, 0, 3 },
    724              },
    725          #endif
    726          #if defined(HAS_BROADCASTRECEIVE)
    727              {
    728                  NULL,
    729                  BroadcastReceiveData,
    730                  BroadcastSend_TimeOut,
    731                  NULL,
    732                  { DevBroadcastReceive, 0, 30 },
    733              },
    734          #endif
    735          #if defined(HAS_125KREADER)
    736              {
    737                  NULL, NULL, sensor125kReaderTimeout, sensor125kReaderResAvailable,
    738                  { Dev125kReader, 0, 10 },
    739              },
    740          #endif
    741          #if defined(HAS_SPEAKER)
    742              {
    743                  NULL, outputSpeaker, outputSpeakerTimeout, OutputSpeakerResAvailable,
    744                  { DevSpeaker, 0, 9 },              // type, id, refresh cycle
    745              },
    746          #endif
    747          #if defined(HAS_IRDecode)
    748              {
    749                  NULL, NULL, IRDecodeTimeout, IRDecodeResAvailable,
    750                  { DevIRDecode, 0, 5 },              // type, id, refresh cycle
    751              },
    752          #endif
    753          #if defined(ZDO_COORDINATOR)
    754              {   // 协调器
    755                  CoordinatorNwkStateChangeRoutine,
    756                  CoordinatorIncomingRoutine,
    757                  CoordinatorTimeoutRoutine,
    758                  CoordinatorResAvailableRoutine,
    759                  { DevCoordinator, 0, 0 },
    760              },
    761          #elif defined(RTR_NWK)
    762              {   // 路由器
    763                  RouterNwkStateChangeRoutine,
    764                  RouterIncomingRoutine,
    765                  RouterTimeoutRoutine,
    766                  RouterResAvailableRoutine,
    767                  { DevRouter, 0, 30 },
    768              },
    769          #endif
    770          };
    771          
    772          // 不能修改下面的内容!!!

   \                                 In  segment XDATA_ROM_C, align 1
    773          const uint8 funcCount = sizeof(funcList) / sizeof(funcList[0]);
   \                     funcCount:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for funcList>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??outputExecuteB::?relay`
   \   000004   ....         DW `??outputExecuteBTimeout::?relay`
   \   000006   ....         DW `??OutputExecuteBResAvailable::?relay`
   \   000008   0B           DB 11
   \   000009   03           DB 3
   \   00000A   0A           DB 10
   \   00000B   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000013   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001B   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    
    774          #endif

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      9   OutputExecuteBResAvailable
        0      9   -> HalIOSetLevel
        0      9   -> HalIOSetOutput
      0     15   outputExecuteB
        0     11   -> HalIOSetLevel
        0     13   -> SendData
      1     12   outputExecuteBTimeout
        0     12   -> SendData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      33  ?<Initializer for funcList>
       5  ?Subroutine0
      13  ?Subroutine1
      10  ?Subroutine2
      76  OutputExecuteBResAvailable
       1  _A_P1
       1  funcCount
      33  funcList
     121  outputExecuteB
      75  outputExecuteBTimeout
      18  -- Other

 
 300 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
  33 bytes in segment XDATA_I
  33 bytes in segment XDATA_ID
   1 byte  in segment XDATA_ROM_C
 
  51 bytes of CODE     memory
   1 byte  of CONST    memory
   0 bytes of DATA     memory (+ 1 byte shared)
 300 bytes of HUGECODE memory
  33 bytes of XDATA    memory

Errors: none
Warnings: none
